---
layout: lesson
root: ../..
---

```{r, include = FALSE}
source("chunk_options.R")
opts_chunk$set(fig.path = "figure/03-apply-R-")
```

# Learning the apply family of functions

One of the greatest joys of vectorized operations is being able to use the
entire family of `apply` functions that are available in base `R`.

These include:

```{r, eval = FALSE}
apply
by
lapply
tapply
sapply
```

## apply

`apply` applies a function to each row or column of a matrix. It's a convenient
way to get marginal values. It follows this syntax: `apply(object, dimension,
function)`.

```{r}
m <- matrix(c(1:10, 11:20), nrow = 10, ncol = 2)
m
# 1 is the row index
# 2 is the column index
apply(m, 1, sum)  # row totals
apply(m, 2, sum)  # column totals
apply(m, 1, mean)
apply(m, 2, mean)
```

There are convenience functions based on `apply`: `rowSums(x)`, `colSums(x)`,
`rowMeans(x)`, `colMeans(x)`, `addmargins`.

## by

`by` applies a function to subsets of a data frame.

```{r}
cow <- data.frame(cow = 1:100,
                  milk = rnorm(100, mean = 30, sd = 9),
                  parity = sample(c("1", "2", "2+"), 100, replace = TRUE),
                  breed = sample(c("HO", "JE", "AY", "BS"), 100, replace = TRUE))
by(cow$milk, cow[, "parity"], summary)
by(cow$milk, cow[, "parity"], sum)
```


## tapply

`tapply` applies a function to subsets of a vector.

```{r}
tapply(cow$milk, cow$parity, mean)
kg_to_lb <- function(x){mean(x * 2.205)}
tapply(cow$milk, cow$parity, kg_to_lb)
```

`tapply()` returns an array; `by()`returns a list. 

## lapply (and llply)

What it does: Returns a list of same length as the input. 
Each element of the output is a result of applying a function to the
corresponding element.

```{r}
my_list <- list(a = 1:10, b = 2:20)
my_list
lapply(my_list, mean)
```


## sapply

`sapply` is a more user friendly version of `lapply` and will return a list of
matrix where appropriate.

Let's work with the same list we just created.

```{r}
my_list
x <- sapply(my_list, mean)
x
class(x)
```


## replicate

An extremely useful function to generate datasets for simulation purposes. 

```{r}
replicate(10, rnorm(10))
replicate(10, rnorm(10), simplify = TRUE)
```

The final arguments turns the result into a vector or matrix if possible.


## mapply
Its more or less a multivariate version of `sapply`. It applies a function to
all corresponding elements of each argument. 

example:

```{r}
list_1 <- list(a = c(1:10), b = c(11:20))
list_1
list_2 <- list(c = c(21:30), d = c(31:40))
list_2
mapply(sum, list_1$a, list_1$b, list_2$c, list_2$d)
```


---

* `apply` functions are more computationally efficient than loops
* you could also use `reshape2` and
  [`plyr`](http://plyr.had.co.nz/)/[`dplyr`](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)
  packages


---

## aggregate

```{r}
aggregate(milk ~ parity + breed, data = cow, FUN = mean)
```


## table

```{r}
t1 <- table(cow$parity)
t1
t2 <- table(cow$parity, cow$breed)
t2

prop.table(t1)
prop.table(t2)
prop.table(t2, margin = 2)
```

See also `xtabs()`, `ftable()` or `CrossTable()` (in library `gmodels`).

### Exercise

With the wide format `health` dataset you created, what is the median cow age in
each herd?


### Solution

```{r}
aggregate(age ~ herd, data = health.wide, FUN = median)
```

---

## Split-Apply-Combine in Action

The following figure can give you a sense of what is split-apply-combine.

![](split.png)

`plyr` package cna be used to apply the split-apply-combine strategy. You need
to provide the follwoing information:

1. The data structure of the input
2. The dataset being worked on
3. The variable to split the dataset on.
4. The function to apply to each split piece.
5. The data structure of the output to combine pieces.

In short, `plyr` synthetizes the entire `*apply` family. For example, the mean
age by herd and parity could be computed and saved into a data frame:

```{r}
lact <- ddply(health.wide,
              .(herd, parity),
              summarize,
              mean.age = mean(age)
              )
```

Two other packages can also be helpful in applying this strategyL `dplyr` and
`data.table`.
